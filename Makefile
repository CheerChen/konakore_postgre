# Makefile for managing the development and deployment lifecycle

# Load local overrides if exists (not tracked by git)
# Copy Makefile.local.example to Makefile.local and fill in your values
-include Makefile.local

# --- Variables ---
# Your private registry URL. Can be overridden e.g., `make push REGISTRY_URL=my.registry.com`
REGISTRY_URL ?= 192.168.0.110:5000

# Service names used in docker-compose
API_SERVICE_NAME := api
SCHEDULER_SERVICE_NAME := scheduler
FILE_SYNC_SERVICE_NAME := file_sync
FRONTEND_SERVICE_NAME := frontend
POSTGRES_SERVICE_NAME := postgres

# Image names in your private registry
API_IMAGE_NAME := my-konakore-api
SCHEDULER_IMAGE_NAME := my-konakore-scheduler
FILE_SYNC_IMAGE_NAME := my-konakore-file-sync
FRONTEND_IMAGE_NAME := my-konakore-frontend
POSTGRES_IMAGE_NAME := my-konakore-postgre

# Image version/tag
TAG ?= latest

# Project name derived from the current directory, used by docker-compose
PROJECT_NAME := $(shell basename $(CURDIR))

# Final image names generated by docker-compose (e.g., konakore_postgre_api)
LOCAL_API_IMAGE := $(PROJECT_NAME)_$(API_SERVICE_NAME)
LOCAL_SCHEDULER_IMAGE := $(PROJECT_NAME)_$(SCHEDULER_SERVICE_NAME)
LOCAL_FILE_SYNC_IMAGE := $(PROJECT_NAME)_$(FILE_SYNC_SERVICE_NAME)
LOCAL_FRONTEND_IMAGE := $(PROJECT_NAME)_$(FRONTEND_SERVICE_NAME)
LOCAL_POSTGRES_IMAGE := $(PROJECT_NAME)_$(POSTGRES_SERVICE_NAME)


# --- Local Development ---
.PHONY: build up down restart logs logs-api logs-scheduler logs-file-sync logs-frontend build-frontend dev-frontend uv-lock

# Generate uv.lock files for all Python services (run this before building)
uv-lock:
	@echo "--> Generating uv.lock files for Python services..."
	cd api && uv lock
	cd file_sync && uv lock
	cd scheduler && uv lock

# Build the custom docker images for api, scheduler, file_sync, and frontend
build:
	@echo "--> Building local Docker images..."
	docker-compose build

# Build only the frontend image
build-frontend:
	@echo "--> Building frontend Docker image..."
	docker-compose build frontend

# Start frontend in development mode (outside Docker)
dev-frontend:
	@echo "--> Starting frontend in development mode..."
	cd frontend && npm run dev

# Start all services in detached mode
up:
	@echo "--> Starting all services..."
	docker-compose up -d

# Stop and remove all services
down:
	@echo "--> Stopping all services..."
	docker-compose down

# Restart all services
restart: down up

# Tail logs from all services
logs:
	@echo "--> Tailing logs for all services..."
	docker-compose logs -f

# Tail logs for the api service
logs-api:
	@echo "--> Tailing logs for the api service..."
	docker-compose logs -f api

# Tail logs for the scheduler service
logs-scheduler:
	@echo "--> Tailing logs for the scheduler service..."
	docker-compose logs -f scheduler

# Tail logs for the file_sync service
logs-file-sync:
	@echo "--> Tailing logs for the file_sync service..."
	docker-compose logs -f file_sync

# Tail logs for the frontend service
logs-frontend:
	@echo "--> Tailing logs for the frontend service..."
	docker-compose logs -f frontend


# --- Deployment ---
.PHONY: tag push release

# Tag the freshly built images for the private registry
tag: build
	@echo "--> Tagging images for registry at $(REGISTRY_URL)..."
	docker tag $(LOCAL_API_IMAGE) $(REGISTRY_URL)/$(API_IMAGE_NAME):$(TAG)
	docker tag $(LOCAL_SCHEDULER_IMAGE) $(REGISTRY_URL)/$(SCHEDULER_IMAGE_NAME):$(TAG)
	docker tag $(LOCAL_FILE_SYNC_IMAGE) $(REGISTRY_URL)/$(FILE_SYNC_IMAGE_NAME):$(TAG)
	docker tag $(LOCAL_FRONTEND_IMAGE) $(REGISTRY_URL)/$(FRONTEND_IMAGE_NAME):$(TAG)
	docker tag $(LOCAL_POSTGRES_IMAGE) $(REGISTRY_URL)/$(POSTGRES_IMAGE_NAME):$(TAG)

# Push the tagged images to the private registry
push:
	@echo "--> Pushing images to registry at $(REGISTRY_URL)..."
	docker push $(REGISTRY_URL)/$(API_IMAGE_NAME):$(TAG)
	docker push $(REGISTRY_URL)/$(SCHEDULER_IMAGE_NAME):$(TAG)
	docker push $(REGISTRY_URL)/$(FILE_SYNC_IMAGE_NAME):$(TAG)
	docker push $(REGISTRY_URL)/$(FRONTEND_IMAGE_NAME):$(TAG)
	docker push $(REGISTRY_URL)/$(POSTGRES_IMAGE_NAME):$(TAG)

# Perform the full release cycle for all images
release: tag push
	@echo "--> Release for api, scheduler, file_sync, and frontend images is complete."


# --- Portainer Remote Deployment ---
.PHONY: portainer-redeploy portainer-redeploy-service

# Portainer configuration (can be overridden via environment or command line)
PORTAINER_URL ?= http://192.168.0.110:9000
PORTAINER_API_KEY ?= 
PORTAINER_STACK_NAME ?= 
PORTAINER_ENDPOINT_ID ?= 2

# Redeploy entire stack in Portainer (re-pull images and redeploy)
# Usage: make portainer-redeploy PORTAINER_API_KEY=your_api_key PORTAINER_STACK_NAME=your_stack
portainer-redeploy:
	@echo "--> Redeploying stack '$(PORTAINER_STACK_NAME)' in Portainer..."
	@if [ -z "$(PORTAINER_API_KEY)" ]; then \
		echo "Error: PORTAINER_API_KEY is required. Set it via environment or command line."; \
		exit 1; \
	fi
	@if [ -z "$(PORTAINER_STACK_NAME)" ]; then \
		echo "Error: PORTAINER_STACK_NAME is required. Usage: make portainer-redeploy PORTAINER_STACK_NAME=your_stack"; \
		exit 1; \
	fi
	@STACK_ID=$$(curl -s -X GET \
		"$(PORTAINER_URL)/api/stacks" \
		-H "X-API-Key: $(PORTAINER_API_KEY)" \
		| jq -r '.[] | select(.Name=="$(PORTAINER_STACK_NAME)") | .Id'); \
	if [ -z "$$STACK_ID" ] || [ "$$STACK_ID" = "null" ]; then \
		echo "Error: Stack '$(PORTAINER_STACK_NAME)' not found."; \
		exit 1; \
	fi; \
	echo "Found stack ID: $$STACK_ID"; \
	STACK_FILE=$$(curl -s -X GET \
		"$(PORTAINER_URL)/api/stacks/$$STACK_ID/file" \
		-H "X-API-Key: $(PORTAINER_API_KEY)" \
		| jq -r '.StackFileContent'); \
	curl -s -X PUT \
		"$(PORTAINER_URL)/api/stacks/$$STACK_ID?endpointId=$(PORTAINER_ENDPOINT_ID)" \
		-H "X-API-Key: $(PORTAINER_API_KEY)" \
		-H "Content-Type: application/json" \
		-d "$$(jq -n --arg content "$$STACK_FILE" '{stackFileContent: $$content, prune: true, pullImage: true}')" \
		| jq .; \
	echo "--> Stack redeployed successfully."

# Remove and recreate a specific service/container in Portainer stack
# Usage: make portainer-redeploy-service PORTAINER_API_KEY=your_api_key PORTAINER_STACK_NAME=your_stack SERVICE=frontend
portainer-redeploy-service:
	@echo "--> Redeploying service '$(SERVICE)' in stack '$(PORTAINER_STACK_NAME)'..."
	@if [ -z "$(PORTAINER_API_KEY)" ]; then \
		echo "Error: PORTAINER_API_KEY is required."; \
		exit 1; \
	fi
	@if [ -z "$(PORTAINER_STACK_NAME)" ]; then \
		echo "Error: PORTAINER_STACK_NAME is required."; \
		exit 1; \
	fi
	@if [ -z "$(SERVICE)" ]; then \
		echo "Error: SERVICE is required. Usage: make portainer-redeploy-service SERVICE=frontend"; \
		exit 1; \
	fi
	@CONTAINER_NAME="$(PORTAINER_STACK_NAME)-$(SERVICE)-1"; \
	echo "Looking for container: $$CONTAINER_NAME"; \
	CONTAINER_ID=$$(curl -s -X GET \
		"$(PORTAINER_URL)/api/endpoints/$(PORTAINER_ENDPOINT_ID)/docker/containers/json?all=true" \
		-H "X-API-Key: $(PORTAINER_API_KEY)" \
		| jq -r ".[] | select(.Names[] | contains(\"$$CONTAINER_NAME\")) | .Id"); \
	if [ -n "$$CONTAINER_ID" ] && [ "$$CONTAINER_ID" != "null" ]; then \
		echo "Stopping container $$CONTAINER_ID..."; \
		curl -s -X POST \
			"$(PORTAINER_URL)/api/endpoints/$(PORTAINER_ENDPOINT_ID)/docker/containers/$$CONTAINER_ID/stop" \
			-H "X-API-Key: $(PORTAINER_API_KEY)" || true; \
		echo "Removing container $$CONTAINER_ID..."; \
		curl -s -X DELETE \
			"$(PORTAINER_URL)/api/endpoints/$(PORTAINER_ENDPOINT_ID)/docker/containers/$$CONTAINER_ID?force=true" \
			-H "X-API-Key: $(PORTAINER_API_KEY)"; \
	else \
		echo "Container not found, proceeding with stack redeploy..."; \
	fi
	@$(MAKE) portainer-redeploy PORTAINER_API_KEY=$(PORTAINER_API_KEY)


# --- Help ---
.PHONY: help

# Display this help message
help:
	@echo "Usage: make [target]"
	@echo ""
	@echo "Local Development:"
	@echo "  uv-lock        Generate uv.lock files for all Python services"
	@echo "  build          Build Docker images for api, scheduler, file_sync, and frontend"
	@echo "  build-frontend Build only the frontend Docker image"
	@echo "  dev-frontend   Start frontend in development mode (outside Docker)"
	@echo "  up             Start services in detached mode"
	@echo "  down           Stop and remove services"
	@echo "  restart        Restart all services"
	@echo "  logs           Tail logs from all services"
	@echo "  logs-api       Tail logs from the api service"
	@echo "  logs-scheduler Tail logs from the scheduler service"
	@echo "  logs-file-sync Tail logs from the file_sync service"
	@echo "  logs-frontend  Tail logs from the frontend service"
	@echo ""
	@echo "Deployment:"
	@echo "  tag            Tag the api, scheduler, file_sync, and frontend images for the registry"
	@echo "  push           Push the tagged images to the registry"
	@echo "  release        Build, tag, and push all custom images"
	@echo ""
	@echo "Portainer Remote Deployment:"
	@echo "  portainer-redeploy          Redeploy entire stack (re-pull images)"
	@echo "                              Usage: make portainer-redeploy PORTAINER_STACK_NAME=xxx PORTAINER_API_KEY=xxx"
	@echo "  portainer-redeploy-service  Remove specific container and redeploy stack"
	@echo "                              Usage: make portainer-redeploy-service PORTAINER_STACK_NAME=xxx SERVICE=frontend PORTAINER_API_KEY=xxx"
	@echo ""
	@echo "Environment Variables:"
	@echo "  PORTAINER_URL        Portainer URL (default: http://192.168.0.110:9000)"
	@echo "  PORTAINER_API_KEY    Portainer API key (required for portainer-* commands)"
	@echo "  PORTAINER_STACK_NAME Stack name (required for portainer-* commands)"
	@echo "  PORTAINER_ENDPOINT_ID Endpoint ID (default: 2)"
